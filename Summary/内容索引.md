### 1.内核级线程与用户级线程的区别
  * 用户级线程：
  
    1.用户级线程所在的进程中维护着一份线程表，每次调度线程时都要修改线程控制值块的状态，应为线程表存在于进程中，所以相较内核级线程，不用系统调用陷入内       核，速度快
  
    2.允许每个进程有自己的调度算法
  
    3.但是面临两个问题：
  
      1）碰到阻塞I/O怎么办，无法通过内核调换线程，只能在阻塞在I/O上，停止其他线程，解决方法可以使用非阻塞I/0或者I/O多路复用
    
      2）在单个线程内部没有时钟中断，除非运行的线程处理完自己的逻辑退出，否则其他线程无法调度，解决方法是需要定义一个调用方法，使得线程能自动退出，即协       程
   * 内核级线程
   
     1.内核维护着一份线程表，可以切换到同一进程的另一线程，也可以切换到另一进程的另一线程
     
     2.不存在用户级线程的问题，但是比较慢
### 2.进程调度方法
    * 非抢占式调度
      1. 先来先服务（FCFS）
      
      2. 最短作业优先(SPN)
      
    * 抢占式调度
      1. 最短剩余作业优先（SRTN）：选择剩余运行时间最短的进程，如果比当前进程短的话就终止当前进程
      
      2. 轮转调度：进程的时间片到达时就切换进程，时间片不能太短或太长
      
      3. 优先级调度： 防止高优先级进程一直占用CPU，可以给进程划分时间片或者每隔一段时间就为将优先值减小一个值，
                     Linux系统中有nice可以控制优先级
      
      4. 反馈法：无法得知剩余时间和总时间就关注当前已运行的时间，处罚运行时间较长的进程，降低其优先度，短进程自
                然就在降低之前完成了，长进程的优先级到达某一程度后就放置在队列末尾
      
      5. 最高响应比：调度选择归一化周转时间最大的进程，归一化时间越大说明进程“年龄”越大。当偏向短作业时（小分母
               产生大比值），长进程由于得不到服务,等待的时间不断增加，从而增大了比值，最终在竞争中可以胜出，同
               样需要预估每个进程所需的处理时间 
      
### 3.内存的分段和分页
   * 分段：
   
         * 分段是将逻辑类型大体相同的的区域分成一个一个连续的虚拟地址空间，这是因为部分区间的大小可能是动态增长的，
           如堆栈段，如果将每一部分都紧密的连续排列在一起会造成地址块的覆盖。
         * 分段就是为了使程序和数据可以被划分成为逻辑上独立的地址空间并且有助于共享和保护。
         * 保护：修改某一个段而不需修改其他段，不会影响覆盖其他段
         * 共享：共享库，可以将共享库放在单独的一个段中由多个进程共享
         
   * 分页与分段组合：
   
         分段中段的大小可能超出物理内存限制，可以采用分页将段的一部分映射到内存空间。
         具体的：
         段选择子选择GDT中的段描述符，段选择子13为index,能够选择8192个段描述符
         段描述符中具有页表号，段基址，段偏移量
### 4.死锁
   * 死锁的四个条件：
   
         1.互斥：资源要么被一个进程占用，要么就是可用的
         2.占有和等待：占有进程的资源可以再请求其他资源
         3.不可抢占式资源：已经分配给一个进程的资源不能被强制性的抢占，除非自己主动释放
         4.环路等待：死锁出现时，肯定有两个或两个以上的进程形成环路
     
   * 死锁检测和恢复：
   
         1.等待死锁发生，然后根据死锁建模。
         2.找有向图的环路（dfs，碰到走过的节点），每种类型资源有多个的情形（未看）
         3.之后回滚到环开始前或杀死一个环上或环外的一个进程。
   * 死锁避免：
   
         1.资源轨迹图
         2.单个资源的银行家算法
           对每一次请求进行检查，检查该请求是否可以到达安全状态，如果可以的话，就满足该请求，否则就推迟对这一请求的满足。
           安全态：从这一状态出发不会造成死锁；
           不安全态：从这一状态开始，可能造成死锁，但不安全不是死锁，因为可能有进程释放资源
         3.多个资源的银行家算法(没看)
         4.无法提前了解进程所需的资源数，且进程数量是变化的，实用意义不大。
   * 死锁预防：
   
         破坏四个死锁条件：
         1.互斥：假脱机打印机守护进程
         2.破坏占有和等待：1）请求资源一步到位 2）先释放已有资源，再尝试一步到位， 难点是知道运行才知道需要多少资源
         3.不可抢占条件：假脱机打印机守护进程
         4.环路等待条件:1)按序请求资源，不允许进程请求比当前占有资源序号低的资源，问题资源优先级次序如何安排
 ### 5.两个线程打印ABAB
 
          #include<stdio.h>
          #include<pthread.h>
          pthread_mutex_t mutex;
          pthread_cond_t conc,conp;
          int buffer=0;
          void *producer(void* ptr){
              while(true){
                  pthread_mutex_lock(&lock);
                  while(buffer==1)
                     pthread_cond_wait(&conp,&mutex);
                  printf("A");
                  pthread_cond_signal(&conc);
                  pthread_mutex_unlock(&lock);
              }
          }
          void *consumer(void* ptr){
              while(true){
                  pthread_mutex_lock(&lock);
                  while(buffer==0)
                     pthread_cond_wait(&conc,&mutex);
                  printf("B");
                  pthread_cond_signal(&conp);
                  pthread_mutex_unlock(&lock);
              }
          }
          int main()
          {}

