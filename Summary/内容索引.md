### 1.内核级线程与用户级线程的区别
  * 用户级线程：
  
    1.用户级线程所在的进程中维护着一份线程表，每次调度线程时都要修改线程控制值块的状态，应为线程表存在于进程中，所以相较内核级线程，不用系统调用陷入内核，速度快
  
    2.允许每个进程有自己的调度算法
  
    3.但是面临两个问题：
  
      1）碰到阻塞I/O怎么办，无法通过内核调换线程，只能在阻塞在I/O上，停止其他线程，解决方法可以使用非阻塞I/0或者I/O多路复用
    
      2）在单个线程内部没有时钟中断，除非运行的线程处理完自己的逻辑退出，否则其他线程无法调度，解决方法是需要定义一个调用方法，使得线程能自动退出，即协程
   * 内核级线程
   
     1.内核维护着一份线程表，可以切换到同一进程的另一线程，也可以切换到另一进程的另一线程
     
     2.不存在用户级线程的问题，但是比较慢
### 2.进程调度方法
    * 非抢占式调度
      1. 先来先服务（FCFS）
      
      2. 最短作业优先(SJF)
      
    * 抢占式调度
      1. 最短剩余作业优先（SRTN）：选择剩余运行时间最短的进程，如果比当前进程短的话就终止当前进程
      
      2. 轮转调度：进程的时间片到达时就切换进程，时间片不能太短或太长
      
      3. 优先级调度： 防止高优先级进程一直占用CPU，可以给进程划分时间片或者每隔一段时间就为将优先值减小一个值，
                     Linux系统中有nice可以控制优先级
      
      4. 反馈法：无法得知剩余时间和总时间就关注当前已运行的时间，处罚运行时间较长的进程，降低其优先度，短进程自
                然就在降低之前完成了，长进程的优先级到达某一程度后就放置在队列末尾
      
      5. 最高响应比：调度选择归一化周转时间最大的进程，归一化时间越大说明进程“年龄”越大。当偏向短作业时（小分母
               产生大比值），长进程由于得不到服务,等待的时间不断增加，从而增大了比值，最终在竞争中可以胜出，同
               样需要预估每个进程所需的处理时间 
      
### 3.内存的分段和分页
   * 分段：
   
         * 分段是将逻辑类型大体相同的的区域分成一个一个连续的虚拟地址空间，这是因为部分区间的大小可能是动态增长的，
           如堆栈段，如果将每一部分都紧密的连续排列在一起会造成地址块的覆盖。
         * 分段就是为了使程序和数据可以被划分成为逻辑上独立的地址空间并且有助于共享和保护。
         * 保护：修改某一个段而不需修改其他段，不会影响覆盖其他段
         * 共享：共享库，可以将共享库放在单独的一个段中由多个进程共享
         
   * 分页与分段组合：
   
         分段中段的大小可能超出物理内存限制，可以采用分页将段的一部分映射到内存空间。
         具体的：
         段选择子选择GDT中的段描述符，段选择子13为index,能够选择8192个段描述符
         段描述符中具有页表号，段基址，段偏移量
### 4.死锁
   * 死锁的四个条件：
   
         1.互斥：资源要么被一个进程占用，要么就是可用的
         2.占有和等待：占有进程的资源可以再请求其他资源
         3.不可抢占式资源：已经分配给一个进程的资源不能被强制性的抢占，除非自己主动释放
         4.环路等待：死锁出现时，肯定有两个或两个以上的进程形成环路
     
   * 死锁检测和恢复：
   
         1.等待死锁发生，然后根据死锁建模。
         2.找有向图的环路（dfs，碰到走过的节点），每种类型资源有多个的情形（未看）
         3.之后回滚到环开始前或杀死一个环上或环外的一个进程。
   * 死锁避免：
   
         1.资源轨迹图
         2.单个资源的银行家算法
           对每一次请求进行检查，检查该请求是否可以到达安全状态，如果可以的话，就满足该请求，否则就推迟对这一请求的满足。
           安全态：从这一状态出发不会造成死锁；
           不安全态：从这一状态开始，可能造成死锁，但不安全不是死锁，因为可能有进程释放资源
         3.多个资源的银行家算法(没看)
         4.无法提前了解进程所需的资源数，且进程数量是变化的，实用意义不大。
   * 死锁预防：
   
         破坏四个死锁条件：
         1.互斥：假脱机打印机守护进程
         2.破坏占有和等待：1）请求资源一步到位 2）先释放已有资源，再尝试一步到位， 难点是知道运行才知道需要多少资源
         3.不可抢占条件：假脱机打印机守护进程
         4.环路等待条件:1)按序请求资源，不允许进程请求比当前占有资源序号低的资源，问题资源优先级次序如何安排
 ### 5.两个线程打印ABAB
 ```c++
          #include<stdio.h>
          #include<pthread.h>
          pthread_mutex_t mutex;
          pthread_cond_t conc,conp;
          int buffer=0;
          void *producer(void* ptr){
              while(true){
                  pthread_mutex_lock(&lock);
                  while(buffer==1)
                     pthread_cond_wait(&conp,&mutex);
                     buffer=1;
                  printf("A");
                  pthread_cond_signal(&conc);
                  pthread_mutex_unlock(&lock);
              }
          }
          void *consumer(void* ptr){
              while(true){
                  pthread_mutex_lock(&lock);
                  while(buffer==0)
                     pthread_cond_wait(&conc,&mutex);
                  buffer=0;
                  printf("B");
                  pthread_cond_signal(&conp);
                  pthread_mutex_unlock(&lock);
              }
          }
          int main()
          {}
```
### 6.只能实例化多次的构造函数（只能实例化一次的构造函数）

          class A{
          public:
             static int count;
             static pthread_mutex_t lock;
             static A getInstance() {
                 if(count<n){
                     pthread_mutex_lock(&lock);
                         if(count<n){
                            ++count;
                            return (new A());
                         }
                     pthread_mutex_unlock(&lock);
                 }
             }
             static void setCount(int n) {Count=n;}
             static void destroy(A* p) {
                  delete p;
                  if(count>0){
                       pthread_mutex_lock(&lock);
                           if(count>0){
                                --count;
                                delete p;
                                p=NULL;
                           }
                       pthread_mutex_unlock(&lock);
                  }   
             }
          private:
             A() {}
             ~B() {}
          }
          int A::count=0;
          pthread_mutex_t A:lock=PTHREAD_MUTEX_INITIALIZER;
### 7.类模板与函数模板的区别
 * 函数模板
   * 函数模板只能全特化
   * 函数模板的模板参数：可以是类型参数，也可以是非类型参数(值，该参数对应的模板实参必须是一个常量表达式)，常见的如函数模板形参中是两个不同长度的数组的引用
   * 函数模板参数推导：通过函数实参推断模板参数类型，也可以通过显示指明类型实例化模板
   * 在分离式编译的条件下，函数模板需要在函数声明中定义，这是因为模板在使用时才会被编译器实例化为二进制代码，对于一般函数，可以头文件和实现分开
 * 类模板
  * 类模板需要显示的在<>里显示指定模板参数，即类型名称
  * 类模板可以在其中定义成员变量，成员函数(静态和非静态)，成员变量也可以也可以类模板，成员函数也可以是函数模板，类内的成员函数在使用时才被实例化
  * 在类模板中通过作用域运算符类访问类型成员时，需要使用typename关键词，这是编译器直到实例化才知道模板定义，但是在处理模板时，比如定义一个声明特定类型的成员变量，必须要知到作用域运算符对应的是类型而不是static变量
  * 可以通过extern 声明模板，在其他源文件中定义，再通过链接，防止多个模板实例代码
  * 类模板可以全特化，也可以偏特化
  
### 8.全特化和偏特化
 * 全特化：不能或者不希望使用函数模板，所有模板参数被指定为特定的类型，特例化实际上是模板的一个实例化
 * 偏特化：只为一些模板参数提供实参或者只是指定一些类型的部分属性，比如类型的指针，类型的引用，**只能偏特化类模板，不能偏特化函数模板**
### 9.std::move以及模板参数中的引用折叠
 * 作用：将左值类型转换为右值类型
 * std::move是一个函数模板
       template<typename T>
       typename remove_reference<T>::type&& move(T&& t){
           return static_cast<typename romove_reference<T>::type&&> (t);
       }
 * 函数模板的参数是模板参数的右值引用，通过引用折叠识别出t或T对应的类型是左值引用还是右值引用，在去掉引用类型，转换成为类型的右值引用
 
### 10.模板参数推导 
 * 名字查找
 * 根据模板实参找到最佳适配：
   * 如果最佳适配中既有模板又有非模板，则优先选择非模板
   * 如果最佳适配中没有非模板，选择最特例化的
   * 二义性错误
### 11.长整数
     //long在64位下为8bytes,但在VS下仍为4bytes，应该和编译器有关
     int m=INT_MAX; int n=2;
     long long res= (long long) m * (long long) n;
     cout<<res<<endl;
     //才能正确打印出res

 
 
 
 
 
