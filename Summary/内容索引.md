### 1.内核级线程与用户级线程的区别
  * 用户级线程：
  
    1.用户级线程所在的进程中维护着一份线程表，每次调度线程时都要修改线程控制值块的状态，应为线程表存在于进程中，所以相较内核级线程，不用系统调用陷入内       核，速度快
  
    2.允许每个进程有自己的调度算法
  
    3.但是面临两个问题：
  
      1）碰到阻塞I/O怎么办，无法通过内核调换线程，只能在阻塞在I/O上，停止其他线程，解决方法可以使用非阻塞I/0或者I/O多路复用
    
      2）在单个线程内部没有时钟中断，除非运行的线程处理完自己的逻辑退出，否则其他线程无法调度，解决方法是需要定义一个调用方法，使得线程能自动退出，即协       程
   * 内核级线程
   
     1.内核维护着一份线程表，可以切换到同一进程的另一线程，也可以切换到另一进程的另一线程
     
     2.不存在用户级线程的问题，但是比较慢
### 2.进程调度方法
    * 非抢占式调度
      1. 先来先服务（FCFS）
      
      2. 最短作业优先(SPN)
      
    * 抢占式调度
      1. 最短剩余作业优先（SRTN）：选择剩余运行时间最短的进程，如果比当前进程短的话就终止当前进程
      
      2. 轮转调度：进程的时间片到达时就切换进程，时间片不能太短或太长
      
      3. 优先级调度： 防止高优先级进程一直占用CPU，可以给进程划分时间片或者每隔一段时间就为将优先值减小一个值，Linux系统中有nice可以控制优先级
      
      4. 反馈法：无法得知剩余时间和总时间就关注当前已运行的时间，处罚运行时间较长的进程，降低其优先度，短进程自然就在降低之前完成了，长进程的优先级到       达某一程度后就放置在队列末尾
      
      5. 最高响应比：调度选择归一化周转时间最大的进程，归一化时间越大说明进程“年龄”越大。当偏向短作业时（小分母产生大比值），长进程由于得不到服务，       等待的时间不断增加，从而增大了比值，最终在竞争中可以胜出，同样需要预估每个进程所需的处理时间 
      
### 3.内存的分段和分页
   * 分段：
   
         分段是将逻辑类型大体相同的的区域分成一个一个连续的虚拟地址空间，这是因为部分区间的大小可能是动态增长的，如堆栈段，如果将每一部分都紧密的连续排列在一起会造成地址块的覆盖。
         分段就是为了使程序和数据可以被划分成为逻辑上独立的地址空间并且有助于共享和保护。
         保护：修改某一个段而不需修改其他段，不会影响覆盖其他段
         共享：共享库，可以将共享库放在单独的一个段中由多个进程共享
         
   * 分页与分段组合：
   
         分段中段的大小可能超出物理内存限制，可以采用分页将段的一部分映射到内存空间。
         具体的：
         段选择子选择GDT中的段描述符，段选择子13为index,能够选择8192个段描述符
         段描述符中具有页表号，段基址，段偏移量
   
   
      
