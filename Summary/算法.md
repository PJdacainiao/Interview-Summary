### 排序
* 快排相比于归并排序以及堆排序的优点

     1. 快速排序的主要效率来源之一是参考位置，其中计算机硬件经过优化，因此访问彼此靠近的存储位置往往比访问分散
     在整个存储器中的存储位置更快。快速排序中的分区步骤通常具有出色的局部性，因为它访问前后靠近的连续数组元
     素。因此，quicksort往往比其他排序算法（如heapsort）表现得更好，即使它经常进行大致相同数量的比较和交换，
     因为在heapsort的情况下，访问更加分散。

     2. 此外，快速排序通常比其他排序算法快得多，因为它可以就地运行，而无需创建任何辅助数组来保存临时值。与merge sort
     之类的东西相比，这可能是一个巨大的优势，因为分配和释放辅助数组所需的时间是显而易见的。就地操作还可以改善快速入口的位置。

     3. 使用链接列表时，这些优点都不一定适用。因为链表单元格通常分散在整个存储器中，所以访问相邻链表单元格没有位置
     加值。因此，quicksort的巨大性能优势之一被消耗殆尽。同样，就地工作的好处不再适用，因为合并排序的链表算法不
     需要任何额外的辅助存储空间。

* 外部排序以及多路归并

     1. 首先将数据逐段读入内存，将每一段数据排序，称为一个顺串,每一段大小记为N，就是内存的大小；
     2. 将每一个顺串按照顺序，依次写到1-K个文件上，记录为Ta1-K,K即为多路归并
     3. 依次读入存储在Ta1-k上的k个顺串的首元素，读入内存并寻找最小的元素，这一步需要o(K)复杂度，将排序好的数据(大小为KN)依次写到Tb1-k上
     4. 递归的读入写入，通过交换Ta1-k和Tb1-k K路归并，知道整个数据排好序写入到磁盘中。
      
     复杂度：需要的交换磁盘的趟数为logk(总的数据长s/内存大小N)\*(s-1)\*(k-1)
     优化：
     1. 无2K个磁盘转化，使用K+1个磁盘，一个磁盘用于交换即可，对于二路归并，使用A,B,C，三个磁盘，初始时分配给A和B两个磁盘，这两个磁盘中的顺串数目应该符合斐波那契数列，K路归并应该符合K阶斐波那契数列(青蛙跳台阶)
     2. K路归并时，使用K越大，时间复杂度递增，使用**败者树**([链接1](https://blog.csdn.net/u010367506/article/details/23565421),[链接2](https://www.cnblogs.com/johnsblog/p/3943352.html))克服，可以在log(K)内找到最小的元素并填充进交换的文件当中。
     
### 随机算法
* [洗牌算法和蓄水池抽样](https://blog.csdn.net/qq_26399665/article/details/79831490)
### 背包算法
* [最大价值](https://blog.csdn.net/yoer77/article/details/70943462)
* [找零钱](https://github.com/PJdacainiao/Interview-Summary/blob/master/Summary/%E7%AE%97%E6%B3%95%E7%B4%A2%E5%BC%95.md#%E7%A1%AC%E5%B8%81%E6%89%BE%E9%9B%B6)

### leetcode
* 236.[两颗二叉树的最小公共祖先](https://www.cnblogs.com/neuzk/p/9487301.html),[二叉树中从根节点到指定节点的路径](https://www.cnblogs.com/neuzk/p/9486730.html)
      
