### 硬币找零
* 贪婪法：是否有最优解，如果是从1-M个连续的零钱，那么必有最优解，使用贪心
* 动态规划
  * 背包算法(先遍历包的数目，再遍历整个包的大小)：若硬币无限多，则为完全背包
 
    * 二维矩阵记录,三重遍历dp[i][j]=min(dp[i-1][j],dp[i-1][j-k*coins[i]]+k)（第i次遍历仅与i-1次遍历有关，与第i-1次前无关，使用一维矩阵）
    * 二维矩阵记录，两重循环dp[i][j]=min(dp[i][j-coins[i]]+1,dp[i-1][j])(三重循环中，第三次遍历K个，重复遍历，使用两重循环遍历)
    * 一维矩阵记录，两重循环dp[j]=min(dp[j],dp[j-coins[i]]+1) 
  * 先遍历包的大小，再遍历包的数目
    * 对于dp[i],dp[i]=min(dp[i-coin[j]]+1)  (i from 1---coins.size() )

### 最长子序列
* 思想：动态规划
  * 一维数组还是二维数组，二维数组一般代表左右区间，扩增区间时是否和前一区间有关联，一维数组代表以index为头或尾完成某件事的记录
  * 对于最长非连续递增子序列：dp[i]代表以nums[i]结尾的最长子序列，则dp[i+1]=max(dp[j]+1) j<i&&nums[i]>nums[j] 或者dp[i]=1
  * 对于最长连续和最大子序列：
### 智能指针
```C++
//使用堆保留计数和资源
template <typename T>
class sharedPtr{
	public:
		sharedPtr():ptr(new T()),count(new int(1)) {}
		explicit sharedPtr(T* t):ptr(t),count(new int(1)) {}
		explicit sharedPtr(T t):ptr(new int(t)),count(new int(1)) {}
		explicit sharedPtr(const sharedPtr& p1):ptr(p1->ptr),count(p1->count) {}
		sharedPtr& operate=(const sharedPtr& p1){
			++*(p1->count);
			if(--(*count)==0){
				delete ptr;
				delete count;
			}
		    ptr=p1->ptr;
			count=p1->count;
			return *this;
		}
		~sharedPtr(){
			if(--(*count)==0){
				delete ptr;
				delete count;
			}
		}
		T* get() const{
            return ptr;
		}
	private:
		T* ptr;
		int *count;
}

//辅助类，全部为私有的，只允许shared_Ptr以友元函数的形式调用
template<typename T> class sharedPtr;
template<typename T>
class tmpPtr{
    friend class sharedPtr<T>;
    tmpPtr():src(new T()),count(1) {}
    tmpPtr(T* p):src(p),count(1) {}
	tmpPtr(T t):src(new T(t)),count(1) {}
    ~tmpPtr() {
            delete src;
    }
    T* src;
    int count;
}
template<typename T>
class sharedPtr{
	sharedPtr():ptr(new tmpPtr()) {}
	explicit sharedPtr(T* p):ptr(new tmpPtr(p)) {}
	explicit sharedPtr(T t):ptr(new tmpPtr<T>(t)) {}
	explicit sharedPtr(const sharedPtr& rhs):ptr(rhs->ptr) {}
	sharedPtr& operate=(const sharedPtr& rhs){
		rhs.ptr->count++;
		if(--(ptr->count)==0)
			delete ptr;
		ptr=rhs.ptr;
		return *this;
	}
    ~ sharedPtr() {
		if(--(ptr->count)==0)
			delete ptr;
	}
	T* get(){
		return ptr->src;
	}

}
```
### 4）判断大小端
```c++
int endian(){
    union{
	   short s;
	   char ch;
	} tmp;
	tmp.s=0x0102;
	if(tmp.ch==2) cout<<"small endian"<<endl;
	else if(tmp.ch==1) cout<<"big endian"<<endl;
	else cout<<"error"<<endl;

}
```
### 单例模式
```c++
//懒汉式，直接就配置好资源
//维护一份静态对象，可以自动构造和析构
class singleton{
	private:
		singleton() {}
		~singleton() {}
		static singleton instance;
	public:
		singleton* getinstance(){
			return &instance;
		}
}
//维护指向堆内存的指针，通过辅助对象tmp在tmp析构时删除指针所指的对象
class singleton{
	private:
		singleton() {}
		~singleton() {}
		static singleton* instance=new singleton();
	public:
		singleton* getinstance()
			return instance;
		}
	private:
		class destroyd{
			public:
			    destroyd() {}
				~destroyd() {
					if(instance!=nullptr)
						delete instance;
				}

		static  destroyd tmp;
		}
}
//饿汉式，线程不安全，需要使用锁变量
//维护一个对象，VS支持static局部变量的线程安全，该局部变量只有一份类似函数中的静态局部变量，知道程序结束才会析构，在第一次遇到时才会初始化
class singleton{
	private:
		singleton() {}
		~singleton() {}
	public:
		singleton* getinstance(){
			static singleton instance;
			return instance;
		}
}
//维护一个对象指针，需要使用双重判断和锁支持线程安全，且要采用辅助类来实现指针对象的析构
class singleton{
	private:
		singleton() {}
		~singleton() {}
		static singleton* instance;
		static std::mutex mtx;
	public:
		singleton* getinstance(){
			if(instance==nullptr){
				mtx.lock();
				if(instance==nullptr){
					instance=new singleton();
				}
				mtx.unlock();
			}
		}
	private:
		class destroyd{
			public:
				destroyd() {}
				~destroyd() {
					if(instance!=nullptr){
						delete instance;
						instance==nullptr;
					}
				}
			}
		static destroyd tmp;
}
}
```
### C字符串函数
* 

